category: Routing
questions:
  -
    question: 'Which of the following is the correct way to define a basic route named `blog_list` for the path `/blog` in a Symfony controller using PHP attributes?'
    answers:
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        class BlogController extends AbstractController
        {
            #[Route("/blog", name: "blog_list")]
            public function list(): Response
            {
                // ...
            }
        }
        ```', correct: true }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        class BlogController extends AbstractController
        {
            /**
             * @Route("/blog", name="blog_list")
             */
            public function list(): Response
            {
                // ...
            }
        }
        ```', correct: false }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Annotation\\Route;
        class BlogController extends AbstractController
        {
            #[Route(path: "/blog", name: "blog_list")]
            public function list(): Response
            {
                // ...
            }
        }
        ```', correct: false }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        class BlogController extends AbstractController
        {
            #[Route("/blog")]
            public function list(): Response
            {
                // ...
            }
        }
        ```', correct: false }
    help: |
      PHP attributes are the modern way to define routes directly in controller classes. The `name` option is crucial for generating URLs.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_1
  -
    question: 'How do you define a basic route named `blog_list` for the path `/blog` in a Symfony YAML configuration file?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path: /blog
            controller: App\\Controller\\BlogController::list
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        - blog_list:
            path: /blog
            controller: App\\Controller\\BlogController::list
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        route_blog_list:
            url: /blog
            action: App\\Controller\\BlogController::list
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            route: /blog
            handler: App\\Controller\\BlogController::list
        ```', correct: false }
    help: |
      YAML is a common format for defining routes. The `path` defines the URL pattern, and `controller` specifies the callable.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_2
  -
    question: 'Which of the following correctly configures Symfony to enable attribute-based routing by scanning the `src/Controller/` directory in YAML?'
    answers:
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource:
                path: ../../src/Controller/
                namespace: App\\Controller
            type: attribute
        ```', correct: true }
      - { value: '```yaml
        # config/routes/attributes.yaml
        app_controllers:
            path: ../../src/Controller/
            type: annotation
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        routes:
            _controller: ../../src/Controller/
            _type: attribute
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        scan_controllers:
            directory: src/Controller/
            format: attributes
        ```', correct: false }
    help: |
      To use PHP attributes for routing, Symfony needs to be configured to load them, typically by scanning a directory.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_0
  -
    question: 'How can you group routes under a common URL prefix `/blog` and name prefix `blog_` using PHP attributes on a controller class?'
    answers:
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        #[Route("/blog", name: "blog_")]
        class BlogController extends AbstractController
        {
            #[Route("/{_locale}", name: "index")]
            public function index(): Response
            {
                // ...
            }
        }
        ```', correct: true }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        #[Route(prefix: "/blog", namePrefix: "blog_")]
        class BlogController extends AbstractController
        {
            #[Route("/{_locale}", name: "index")]
            public function index(): Response
            {
                // ...
            }
        }
        ```', correct: false }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        #[Route(path: "/blog", alias: "blog_")]
        class BlogController extends AbstractController
        {
            #[Route("/{_locale}", name: "index")]
            public function index(): Response
            {
                // ...
            }
        }
        ```', correct: false }
      - { value: '```php
        // src/Controller/BlogController.php
        namespace App\\Controller;
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;
        use Symfony\\Component\\HttpFoundation\\Response;
        use Symfony\\Component\\Routing\\Attribute\\Route;
        #[Route("/blog/*", name: "blog_*")]
        class BlogController extends AbstractController
        {
            #[Route("/{_locale}", name: "index")]
            public function index(): Response
            {
                // ...
            }
        }
        ```', correct: false }
    help: |
      The `#[Route]` attribute can be applied to a controller class to define common settings for all routes within that controller, including `path` for URL prefix and `name` for name prefix.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_37
  -
    question: 'How do you define a route named `product_show` for the path `/product/{id}` in a PHP routing configurator file (`config/routes.php`)?'
    answers:
      - { value: '```php
        // config/routes.php
        use App\\Controller\\ProductController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
        };
        ```', correct: true }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\ProductController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->set("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
        };
        ```', correct: false }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\ProductController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->route("product_show", "/product/{id}")
                    ->action("App\\Controller\\ProductController::show");
        };
        ```', correct: false }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\ProductController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->map("product_show", "/product/{id}")
                    ->to("App\\Controller\\ProductController::show");
        };
        ```', correct: false }
    help: |
      The `RoutingConfigurator` provides a fluent interface for defining routes in PHP files. The `add()` method is used to define a new route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_33
  -
    question: 'How do you add a requirement to a route parameter `page` in PHP attributes to ensure it only matches digits (`\\d+`)?'
    answers:
      - { value: '```php
        #[Route("/blog/{page}", name: "blog_list", requirements: ["page" => "\\d+"])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/blog/{page<\\d+>}", name: "blog_list")]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/blog/{page}", name: "blog_list", regex: ["page" => "\\d+"])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{page}", name: "blog_list", constraints: ["page" => "\\d+"])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Route parameter requirements can be defined using the `requirements` option with a regular expression or directly in the path using the `<REGEX>` syntax.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_17
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_20
  -
    question: 'In YAML, how do you define a requirement for a route parameter `page` to ensure it only accepts digits?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path:       /blog/{page}
            controller: App\\Controller\\BlogController::list
            requirements:
                page: \\d+
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path:       /blog/{page<\\d+>}
            controller: App\\Controller\\BlogController::list
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path:       /blog/{page}
            controller: App\\Controller\\BlogController::list
            regex:
                page: \\d+
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path:       /blog/{page}
            controller: App\\Controller\\BlogController::list
            constraints:
                page: \\d+
        ```', correct: false }
    help: |
      In YAML, requirements are defined under the `requirements` key, with the parameter name as the key and the regular expression as the value.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_17
  -
    question: 'What is the correct way to allow a slash character (`/`) within a route parameter `token` in a Symfony route defined with PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/share/{token}", name: "share", requirements: ["token" => ".+"])]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/share/{token}", name: "share", allowSlash: true)]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/share/{token<.+>}", name: "share")]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/share/{token}", name: "share", defaults: ["token" => ".+"])]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      By default, route parameters do not match the `/` character. To allow it, you must define a requirement that includes it, such as `.+`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_31
  -
    question: 'Why is it important to add requirements to route parameters, especially when routes have similar patterns like `/blog/{page}` and `/blog/{slug}`?'
    answers:
      - { value: 'To improve the performance of route matching by reducing the number of potential matches.', correct: false }
      - { value: 'To prevent greedy patterns from matching more specific routes, ensuring the correct route is chosen.', correct: true }
      - { value: 'To automatically cast the parameter value to the correct PHP type in the controller.', correct: false }
      - { value: 'To enforce security constraints on the parameter values.', correct: false }
    help: |
      Requirements help Symfony differentiate between routes that might otherwise conflict due to similar URL patterns, ensuring the most specific route is matched.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_17
  -
    question: 'How do you set a default value for a route parameter `page` to `1` in PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/articles/{page}", defaults: ["page" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/articles/{page?}", defaults: ["page" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/articles/{page}", default: 1)]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/articles/{page}", options: ["default_page" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Default values for route parameters are defined using the `defaults` option in PHP attributes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst
  -
    question: 'How does Symfony handle PHP backed enumerations (Enums) used as route parameters with default values?'
    answers:
      - { value: 'Symfony automatically converts the Enum case to its scalar value when matching the route and passes the Enum object to the controller.', correct: true }
      - { value: 'Symfony requires a custom ParamConverter to handle Enum parameters.', correct: false }
      - { value: 'Enum parameters must be explicitly converted to strings in the route definition.', correct: false }
      - { value: 'Symfony treats Enum parameters as regular strings and does not perform any special conversion.', correct: false }
    help: |
      Symfony automatically handles PHP backed enums, converting them to their scalar values for routing and injecting the Enum object into the controller.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_26
  -
    question: 'Given the route `#[Route("/articles/{page}", defaults: ["page" => 1])]` in a controller, what will be the value of the `$page` argument in the controller method if the requested URL is `/articles/`?'
    answers:
      - { value: '`1`', correct: true }
      - { value: '`null`', correct: false }
      - { value: '`"page"`', correct: false }
      - { value: 'An exception will be thrown because `page` is not provided in the URL.', correct: false }
    help: |
      If a route parameter has a default value and is not provided in the URL, Symfony uses the default value.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst
  -
    question: 'Which of the following methods should you use within a Symfony controller (extending `AbstractController`) to generate an absolute URL for a route named `sign_up`?'
    answers:
      - { value: '`$this->generateUrl("sign_up", [], UrlGeneratorInterface::ABSOLUTE_URL);`', correct: true }
      - { value: '`$this->router->generate("sign_up", [], true);`', correct: false }
      - { value: '`$this->getUrl("sign_up", [], UrlGeneratorInterface::ABSOLUTE_URL);`', correct: false }
      - { value: '`$this->container->get("router")->generate("sign_up", ["absolute" => true]);`', correct: false }
    help: |
      The `generateUrl()` helper method provided by `AbstractController` is the recommended way to generate URLs in controllers. `UrlGeneratorInterface::ABSOLUTE_URL` specifies the URL type.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_56
  -
    question: 'How do you generate a localized URL for a route named `product_details` for the `nl` locale within a Symfony service, assuming `UrlGeneratorInterface` is injected?'
    answers:
      - { value: '`$this->urlGenerator->generate("product_details", ["_locale" => "nl"]);`', correct: true }
      - { value: '`$this->urlGenerator->generate("product_details", ["locale" => "nl"]);`', correct: false }
      - { value: '`$this->urlGenerator->generate("product_details", [], "nl");`', correct: false }
      - { value: '`$this->urlGenerator->generateLocalized("product_details", "nl");`', correct: false }
    help: |
      To generate a URL for a specific locale, pass the `_locale` parameter in the route arguments.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_59
  -
    question: 'When generating a URL using `UrlGeneratorInterface::generate()`, what is the default URL type if no third argument is provided?'
    answers:
      - { value: 'Absolute URL (e.g., `http://example.com/path`)', correct: false }
      - { value: 'Absolute path (e.g., `/path`)', correct: true }
      - { value: 'Relative path (e.g., `path`)', correct: false }
      - { value: 'Network path (e.g., `//example.com/path`)', correct: false }
    help: |
      By default, `generate()` creates an absolute path, which is relative to the web root.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_56
  -
    question: 'What should you do if you need to pass an object (e.g., a `Uuid` object) as an extra parameter when generating a URL in Symfony?'
    answers:
      - { value: 'Pass the object directly; Symfony will automatically convert it to a string.', correct: false }
      - { value: 'Explicitly convert the object to a string before passing it as a parameter.', correct: true }
      - { value: 'Implement the `__toString()` method on the object and pass it directly.', correct: true }
      - { value: 'Use a custom ParamConverter to handle the object conversion.', correct: false }
    help: |
      When passing objects as extra parameters, they must be explicitly converted to strings, or the object must implement `__toString()`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_58
  -
    question: 'What exception is thrown by the `UrlGeneratorInterface::generate()` method if you attempt to generate a URL for a route with mandatory parameters but fail to provide them?'
    answers:
      - { value: '`Symfony\\Component\\Routing\\Exception\\MissingMandatoryParametersException`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Exception\\RouteNotFoundException`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Exception\\InvalidParameterException`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Exception\\MissingMandatoryParametersException` (or a similar message indicating missing parameters)', correct: true }
    help: |
      If mandatory parameters are missing, Symfony will throw an exception indicating this.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_73
  -
    question: 'How do you configure a permanent redirect from `/doc` to an internal route named `doc_page` in YAML, ensuring query parameters are preserved and the HTTP method is kept?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        doc_shortcut:
            path: /doc
            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController
            defaults:
                route: "doc_page"
                permanent: true
                keepQueryParams: true
                keepRequestMethod: true
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        doc_shortcut:
            path: /doc
            redirect_to: doc_page
            permanent: true
            preserve_query: true
            preserve_method: true
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        doc_shortcut:
            path: /doc
            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController::urlRedirect
            defaults:
                route: "doc_page"
                status: 301
                query: true
                method: true
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        doc_shortcut:
            path: /doc
            redirect:
                route: doc_page
                type: permanent
                query_params: true
                http_method: true
        ```', correct: false }
    help: |
      The `RedirectController` is used for redirects. Options like `permanent`, `keepQueryParams`, and `keepRequestMethod` control the redirect behavior.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'What HTTP status code is used for a temporary redirect when the `keepRequestMethod` option is set to `true` in Symfony''s `RedirectController`?'
    answers:
      - { value: '302 Found', correct: false }
      - { value: '307 Temporary Redirect', correct: true }
      - { value: '301 Moved Permanently', correct: false }
      - { value: '308 Permanent Redirect', correct: false }
    help: |
      When `keepRequestMethod` is true, temporary redirects use 307, and permanent redirects use 308.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'What is the purpose of the `ignoreAttributes` option when configuring a redirect using Symfony''s `RedirectController`?'
    answers:
      - { value: 'To prevent certain attributes from being passed to the redirected route.', correct: true }
      - { value: 'To ignore all query parameters from the original request during redirection.', correct: false }
      - { value: 'To disable logging of specific route attributes during the redirect process.', correct: false }
      - { value: 'To ensure that the original request attributes are always preserved.', correct: false }
    help: |
      `ignoreAttributes` allows you to specify which original route attributes should not be passed to the redirected route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'Which of the following special route parameters is used to determine which controller and action is executed when a route is matched?'
    answers:
      - { value: '`_controller`', correct: true }
      - { value: '`_action`', correct: false }
      - { value: '`_handler`', correct: false }
      - { value: '`_target`', correct: false }
    help: |
      The `_controller` parameter holds the callable string for the controller and its method.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which special route parameter is used to set the `locale` on the `Request` object in Symfony?'
    answers:
      - { value: '`_locale`', correct: true }
      - { value: '`_lang`', correct: false }
      - { value: '`_language`', correct: false }
      - { value: '`_culture`', correct: false }
    help: |
      The `_locale` parameter is specifically designed to manage the request locale.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'How do you define a route in PHP attributes that explicitly sets the default locale to `en` and format to `html`, with requirements that `_locale` can be `en|fr` and `_format` can be `html|xml`?'
    answers:
      - { value: '```php
        #[Route(
            path: "/articles/{_locale}/search.{_format}",
            locale: "en",
            format: "html",
            requirements: [
                "_locale" => "en|fr",
                "_format" => "html|xml",
            ],
        )]
        public function search(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route(
            path: "/articles/{_locale}/search.{_format}",
            defaults: ["_locale" => "en", "_format" => "html"],
            requirements: [
                "_locale" => "en|fr",
                "_format" => "html|xml",
            ],
        )]
        public function search(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route(
            path: "/articles/{_locale}/search.{_format}",
            _locale: "en",
            _format: "html",
            requirements: [
                "_locale" => "en|fr",
                "_format" => "html|xml",
            ],
        )]
        public function search(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route(
            path: "/articles/{_locale}/search.{_format}",
            options: ["locale" => "en", "format" => "html"],
            requirements: [
                "_locale" => "en|fr",
                "_format" => "html|xml",
            ],
        )]
        public function search(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Special parameters like `_locale` and `_format` can be configured directly in the route definition using `locale`, `format`, and `requirements` options.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_28
  -
    question: 'How do you define a route that matches a specific subdomain `m.example.com` using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/", name: "mobile_homepage", host: "m.example.com")]
        public function mobileHomepage(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/", name: "mobile_homepage", domain: "m.example.com")]
        public function mobileHomepage(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/", name: "mobile_homepage", host_regex: "m.example.com")]
        public function mobileHomepage(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/", name: "mobile_homepage", requirements: ["_host" => "m.example.com"])]
        public function mobileHomepage(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `host` option in the `#[Route]` attribute allows you to specify a hostname for the route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_46
  -
    question: 'How do you configure a route in YAML to match a dynamic subdomain, e.g., `{subdomain}.example.com`, with a default value for `subdomain` set to `m` and a requirement that `subdomain` can be `m` or `mobile`?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        mobile_homepage:
            path:       /
            host:       "{subdomain}.example.com"
            controller: App\\Controller\\MainController::mobileHomepage
            defaults:
                subdomain: m
            requirements:
                subdomain: m|mobile
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        mobile_homepage:
            path:       /
            host:       "{subdomain}.example.com"
            controller: App\\Controller\\MainController::mobileHomepage
            default_subdomain: m
            subdomain_regex: m|mobile
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        mobile_homepage:
            path:       /
            domain:     "{subdomain}.example.com"
            controller: App\\Controller\\MainController::mobileHomepage
            defaults:
                subdomain: m
            requirements:
                subdomain: m|mobile
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        mobile_homepage:
            path:       /
            host:       "{subdomain}.example.com"
            controller: App\\Controller\\MainController::mobileHomepage
            options:
                subdomain: m
                subdomain_pattern: m|mobile
        ```', correct: false }
    help: |
      Dynamic host parameters are defined similarly to path parameters, with `defaults` and `requirements` applying to the host.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_47
  -
    question: 'What is the primary benefit of using host-based routing in Symfony?'
    answers:
      - { value: 'It allows for better organization of routes by separating them into different files based on the host.', correct: false }
      - { value: 'It enables serving different content or applications from the same Symfony instance based on the requested domain or subdomain.', correct: true }
      - { value: 'It automatically redirects users to the correct subdomain based on their locale.', correct: false }
      - { value: 'It improves SEO by providing unique URLs for different parts of an application.', correct: false }
    help: |
      Host-based routing is essential for applications that need to serve different content or functionalities based on the domain or subdomain, such as mobile versions or multi-tenant applications.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_46
  -
    question: 'How can you import a collection of routes and apply host-based routing rules for different locales (e.g., `www.example.com` for `en` and `www.example.nl` for `nl`) using the PHP routing configurator?'
    answers:
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->host([
                    "en" => "www.example.com",
                    "nl" => "www.example.nl",
                ])
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->hosts([
                    "en" => "www.example.com",
                    "nl" => "www.example.nl",
                ])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->domain([
                    "en" => "www.example.com",
                    "nl" => "www.example.nl",
                ])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->addHostMapping([
                    "en" => "www.example.com",
                    "nl" => "www.example.nl",
                ])
            ;
        };
        ```', correct: false }
    help: |
      The `host()` method on an imported route collection allows applying host-based routing rules to all imported routes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_53
  -
    question: 'How do you add a condition to a route in PHP attributes that checks if the HTTP method is `GET` or `HEAD` AND the `User-Agent` header matches `/firefox/i`?'
    answers:
      - { value: '```php
        #[Route(
            "/contact",
            name: "contact",
            condition: "context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches \'/firefox/i\'",
        )]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route(
            "/contact",
            name: "contact",
            requirements: [
                "_method" => "GET|HEAD",
                "_header_User-Agent" => "/firefox/i",
            ],
        )]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route(
            "/contact",
            name: "contact",
            when: "method in ['GET', 'HEAD'] and header(\'User-Agent\') matches \'/firefox/i\'",
        )]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route(
            "/contact",
            name: "contact",
            expression: "request.isMethod('GET') or request.isMethod('HEAD') and request.headers.get('User-Agent') matches '/firefox/i'",
        )]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `condition` option accepts an Expression Language string that can access `context` (RequestContext) and `request` (Request) objects.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_7
  -
    question: 'Which of the following variables are available for use within Symfony''s Expression Language for routing conditions?'
    answers:
      - { value: '`context` (Symfony\\Component\\Routing\\RequestContext)', correct: true }
      - { value: '`request` (Symfony\\Component\\HttpFoundation\\Request)', correct: true }
      - { value: '`params` (array of matched route parameters)', correct: true }
      - { value: '`session` (Symfony\\Component\\HttpFoundation\\Session\\SessionInterface)', correct: false }
    help: |
      The `context`, `request`, and `params` variables are directly available in routing conditions.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'What is the purpose of the `service()` function in Symfony routing conditions?'
    answers:
      - { value: 'It allows you to call any public method of a service defined in the service container.', correct: false }
      - { value: 'It returns an instance of a routing condition service, which must be tagged with `#[AsRoutingConditionService]` or `routing.condition_service`.', correct: true }
      - { value: 'It registers a new service dynamically for use in routing conditions.', correct: false }
      - { value: 'It injects a service directly into the routing condition expression.', correct: false }
    help: |
      The `service()` function provides a way to use custom logic defined in services within routing conditions.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'How can you use an environment variable `APP_MAIN_HOST` in a routing condition within the PHP routing configurator?'
    answers:
      - { value: '```php
        $routes->add("homepage", "/")
            ->controller([DefaultController::class, "homepage"])
            ->condition("context.getHost() == env(\"APP_MAIN_HOST\")")
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("homepage", "/")
            ->controller([DefaultController::class, "homepage"])
            ->condition("context.getHost() == getenv(\"APP_MAIN_HOST\")")
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("homepage", "/")
            ->controller([DefaultController::class, "homepage"])
            ->condition("context.getHost() == parameter(\"env.APP_MAIN_HOST\")")
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("homepage", "/")
            ->controller([DefaultController::class, "homepage"])
            ->condition("context.getHost() == %env(APP_MAIN_HOST)%")
        ;
        ```', correct: false }
    help: |
      The `env()` function in Expression Language allows access to environment variables.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_8
  -
    question: 'How do you restrict a route to only accept `POST` requests using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/submit", name: "submit_form", methods: ["POST"])]
        public function submitForm(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/submit", name: "submit_form", method: "POST")]
        public function submitForm(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/submit", name: "submit_form", httpMethod: "POST")]
        public function submitForm(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/submit", name: "submit_form", allowMethods: ["POST"])]
        public function submitForm(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `methods` option in the `#[Route]` attribute takes an array of allowed HTTP methods.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst
  -
    question: 'If a Symfony route does not explicitly define any HTTP methods, which methods does it match by default?'
    answers:
      - { value: 'Only `GET` requests.', correct: false }
      - { value: 'Only `GET` and `POST` requests.', correct: false }
      - { value: 'All HTTP methods (equivalent to `ANY`).', correct: true }
      - { value: 'No methods, an exception is thrown.', correct: false }
    help: |
      By default, if no methods are specified, a route will match any HTTP method.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_12 (Observe the "Method" column for `homepage` route)
  -
    question: 'Why is it generally considered a good practice to specify HTTP methods for routes in Symfony?'
    answers:
      - { value: 'To improve routing performance by reducing the number of routes to check.', correct: false }
      - { value: 'To enforce RESTful API design principles and clarify the intended action of a URL.', correct: true }
      - { value: 'To automatically generate correct HTTP response headers.', correct: false }
      - { value: 'To prevent cross-site scripting (XSS) attacks.', correct: false }
    help: |
      Specifying HTTP methods helps in building well-structured and predictable APIs, adhering to REST principles, and preventing unintended access.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'How do you define localized paths for a single route named `about_us` using PHP attributes, with `/about-us` for English (`en`) and `/over-ons` for Dutch (`nl`)?'
    answers:
      - { value: '```php
        #[Route(path: [
            "en" => "/about-us",
            "nl" => "/over-ons"
        ], name: "about_us")]
        public function about(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route(
            path: "/about-us",
            name: "about_us",
            localized_paths: ["nl" => "/over-ons"]
        )]
        public function about(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/about-us", name: "about_us")]
        #[Route("/over-ons", name: "about_us", locale: "nl")]
        public function about(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route(path: "/about-us", name: "about_us")]
        #[Route(path: "/over-ons", name: "about_us_nl")]
        public function about(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Localized routes can be defined by providing an array of paths keyed by locale in the `path` option of the `#[Route]` attribute.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_50
  -
    question: 'How do you define localized paths for a single route named `about_us` in YAML, with `/about-us` for English (`en`) and `/over-ons` for Dutch (`nl`)?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        about_us:
            path:
                en: /about-us
                nl: /over-ons
            controller: App\\Controller\\CompanyController::about
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        about_us:
            path: /about-us
            locale_paths:
                nl: /over-ons
            controller: App\\Controller\\CompanyController::about
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        about_us_en:
            path: /about-us
            controller: App\\Controller\\CompanyController::about
        about_us_nl:
            path: /over-ons
            controller: App\\Controller\\CompanyController::about
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        about_us:
            path: /about-us
            translations:
                nl: /over-ons
            controller: App\\Controller\\CompanyController::about
        ```', correct: false }
    help: |
      In YAML, localized paths are defined under the `path` key as a map of locales to their respective paths.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_50
  -
    question: 'How does Symfony determine the user''s locale for routing purposes if it is not explicitly set in the URL?'
    answers:
      - { value: 'It always defaults to the `_locale` value defined in the route defaults.', correct: false }
      - { value: 'It tries to guess the locale from the `Accept-Language` HTTP header of the request.', correct: true }
      - { value: 'It uses the default locale configured in `framework.yaml`.', correct: false }
      - { value: 'It prompts the user to select a locale.', correct: false }
    help: |
      Symfony can guess the user's locale from the `Accept-Language` header if no `_locale` is explicitly provided in the route.
      https://symfony.com/doc/current/translation/locale.html#locale-guessing
  -
    question: 'Which command-line tool is used to list all registered routes in a Symfony application?'
    answers:
      - { value: '`php bin/console debug:router`', correct: true }
      - { value: '`php bin/console router:list`', correct: false }
      - { value: '`php bin/console routes:show`', correct: false }
      - { value: '`php bin/console app:routes`', correct: false }
    help: |
      The `debug:router` command provides a comprehensive list of all defined routes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_12
  -
    question: 'How can you display detailed information for a specific route named `app_lucky_number` using the command line?'
    answers:
      - { value: '`php bin/console debug:router app_lucky_number`', correct: true }
      - { value: '`php bin/console router:info app_lucky_number`', correct: false }
      - { value: '`php bin/console show:route app_lucky_number`', correct: false }
      - { value: '`php bin/console route:details app_lucky_number`', correct: false }
    help: |
      Passing the route name as an argument to `debug:router` shows its detailed properties.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_14
  -
    question: 'How do you list all routes that match the `GET` HTTP method using the `debug:router` command?'
    answers:
      - { value: '`php bin/console debug:router --method=GET`', correct: true }
      - { value: '`php bin/console debug:router --http-method=GET`', correct: false }
      - { value: '`php bin/console debug:router --filter-method=GET`', correct: false }
      - { value: '`php bin/console debug:router --only-get`', correct: false }
    help: |
      The `--method` option filters routes by the specified HTTP method.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_13
  -
    question: 'Which command helps you determine which Symfony route matches a specific URL path, such as `/lucky/number/8`?'
    answers:
      - { value: '`php bin/console router:match /lucky/number/8`', correct: true }
      - { value: '`php bin/console debug:url /lucky/number/8`', correct: false }
      - { value: '`php bin/console route:find /lucky/number/8`', correct: false }
      - { value: '`php bin/console match:route /lucky/number/8`', correct: false }
    help: |
      The `router:match` command is specifically designed to identify the route matching a given URL.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_15
  -
    question: 'How can you mark a route as `stateless` in Symfony using PHP attributes, and what is the primary effect of doing so?'
    answers:
      - { value: '```php
        #[Route("/", name: "homepage", stateless: true)]
        public function homepage(): Response
        {
            // ...
        }
        ```
        It prevents the route from using sessions during request matching, improving caching.', correct: true }
      - { value: '```php
        #[Route("/", name: "homepage", cacheable: true)]
        public function homepage(): Response
        {
            // ...
        }
        ```
        It enables HTTP caching for the route by default.', correct: false }
      - { value: '```php
        #[Route("/", name: "homepage", session_less: true)]
        public function homepage(): Response
        {
            // ...
        }
        ```
        It ensures that no user data is stored in the session for this route.', correct: false }
      - { value: '```php
        #[Route("/", name: "homepage", no_session: true)]
        public function homepage(): Response
        {
            // ...
        }
        ```
        It makes the route accessible without requiring a user login.', correct: false }
    help: |
      The `stateless: true` option on a route prevents session usage during request matching, which can be beneficial for caching.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_54
  -
    question: 'Consider two routes:
        Route A: `#[Route("/blog/{slug}", name: "blog_show")]`
        Route B: `#[Route("/blog/list", name: "blog_list")]`
        If Route B needs to be matched before Route A for the URL `/blog/list`, how can you achieve this using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/blog/{slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        #[Route("/blog/list", name: "blog_list", priority: 1)]
        public function list(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/blog/{slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        #[Route("/blog/list", name: "blog_list", order: -1)]
        public function list(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        #[Route("/blog/list", name: "blog_list", before: "blog_show")]
        public function list(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        #[Route("/blog/list", name: "blog_list", precedence: 1)]
        public function list(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `priority` option (default 0) allows you to explicitly control the order in which routes are evaluated. Higher priority routes are matched first.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_23
  -
    question: 'You have an old route named `product_show` and a new route named `product_details`. You want to deprecate `product_show` and make it an alias of `product_details` with a custom deprecation message. How would you configure this in YAML?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        product_details:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_show:
            alias: product_details
            deprecated:
                package: \'acme/package\'
                version: \'1.2\'
                message: \'The "%alias_id%" route alias is deprecated. Please use "product_details" instead.\'
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        product_details:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_show:
            redirect_to: product_details
            deprecated: true
            message: \'The "product_show" route alias is deprecated. Please use "product_details" instead.\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_details:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_show:
            alias: product_details
            deprecation_message: \'The "product_show" route alias is deprecated. Please use "product_details" instead.\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
            alias_of: product_details
            deprecated:
                message: \'The "product_show" route alias is deprecated. Please use "product_details" instead.\'
        ```', correct: false }
    help: |
      Route aliases can be deprecated using the `deprecated` key, which accepts `package`, `version`, and an optional `message`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_35
  -
    question: 'How can you apply an HTTPS scheme requirement to an entire group of imported routes using YAML configuration?'
    answers:
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            schemes: [https]
        ```', correct: true }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            scheme: https
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            requirements:
                _scheme: https
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            force_https: true
        ```', correct: false }
    help: |
      The `schemes` option can be applied to an imported route collection to enforce specific URL schemes for all routes within that collection.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_68
  -
    question: 'What is the purpose of the `_format` special route parameter in Symfony?'
    answers:
      - { value: 'It is used to define the output format of the response (e.g., JSON, XML).', correct: true }
      - { value: 'It specifies the input format of the request payload.', correct: false }
      - { value: 'It determines the template engine to be used for rendering the view.', correct: false }
      - { value: 'It defines the data format for route parameters.', correct: false }
    help: |
      The `_format` parameter sets the "request format" of the `Request` object, which influences the `Content-Type` of the response.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which of the following is the correct way to define a route with a dynamic slug parameter (`{slug}`) in a Symfony controller using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/blog/{slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/blog/:slug", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{slug?}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{string:slug}", name: "blog_show")]
        public function show(string $slug): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Dynamic route parameters are enclosed in curly braces `{}`. Symfony automatically passes their values to the controller method arguments.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_16
  -
    question: 'How can you define a route that is only active in the `dev` environment using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/tools", name: "tools", env: "dev")]
        public function developerTools(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/tools", name: "tools", environment: "dev")]
        public function developerTools(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/tools", name: "tools", if_env: "dev")]
        public function developerTools(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/tools", name: "tools", condition: "kernel.environment == \'dev\'")]
        public function developerTools(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `env` option in the `#[Route]` attribute allows you to restrict a route to a specific environment.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_5
  -
    question: 'What is the correct way to retrieve the current route''s name and its associated parameters from the `Request` object within a Symfony controller?'
    answers:
      - { value: '```php
        $routeName = $request->attributes->get("_route");
        $routeParameters = $request->attributes->get("_route_params");
        ```', correct: true }
      - { value: '```php
        $routeName = $request->get("_route");
        $routeParameters = $request->get("_route_params");
        ```', correct: false }
      - { value: '```php
        $routeName = $request->getRouteName();
        $routeParameters = $request->getRouteParameters();
        ```', correct: false }
      - { value: '```php
        $routeName = $request->attributes->get("route_name");
        $routeParameters = $request->attributes->get("route_parameters");
        ```', correct: false }
    help: |
      The route name and parameters are stored as attributes on the `Request` object, accessible via `attributes->get()`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_42
  -
    question: 'Which of the following is the recommended way to check if a route exists in Symfony without negatively impacting performance by regenerating the routing cache?'
    answers:
      - { value: 'Attempt to generate the URL for the route and catch `Symfony\\Component\\Routing\\Exception\\RouteNotFoundException`.', correct: true }
      - { value: 'Inspect the `RouteCollection` directly to see if the route name exists.', correct: false }
      - { value: 'Use `php bin/console debug:router` and parse its output.', correct: false }
      - { value: 'Call a method like `$router->routeExists("route_name")`.', correct: false }
    help: |
      Catching `RouteNotFoundException` is the preferred method as it avoids unnecessary cache regeneration.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_63
  -
    question: 'What is the purpose of the `_fragment` special route parameter?'
    answers:
      - { value: 'It is used to set the fragment identifier (the part after `#`) in a URL.', correct: true }
      - { value: 'It defines a part of the URL that is ignored by the router.', correct: false }
      - { value: 'It specifies a section of a page to scroll to after navigation.', correct: false }
      - { value: 'It is used for internal routing within a single page application.', correct: false }
    help: |
      The `_fragment` parameter corresponds to the URL fragment identifier.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'You are importing routes from a controller directory using the PHP routing configurator. How can you apply a URL prefix of `/blog` and a name prefix of `blog_` to all imported routes, while also defining a global requirement that `_locale` must be `en|es|fr`?'
    answers:
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->prefix("/blog")
                ->namePrefix("blog_")
                ->requirements(["_locale" => "en|es|fr"])
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->setPrefix("/blog")
                ->setNamePrefix("blog_")
                ->addRequirements(["_locale" => "en|es|fr"])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute", [
                "prefix" => "/blog",
                "name_prefix" => "blog_",
                "requirements" => ["_locale" => "en|es|fr"],
            ]);
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->configure(prefix: "/blog", namePrefix: "blog_", requirements: ["_locale" => "en|es|fr"])
            ;
        };
        ```', correct: false }
    help: |
      The `import()` method returns a `RouteCollectionBuilder` object, which provides methods like `prefix()`, `namePrefix()`, and `requirements()` for applying common configurations.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_40
  -
    question: 'How can you apply locale-specific URL prefixes to imported routes using the PHP routing configurator, for example, no prefix for `en` and `/nl` for `nl`?'
    answers:
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->prefix([
                    "en" => "",
                    "nl" => "/nl",
                ])
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->localePrefix([
                    "en" => "",
                    "nl" => "/nl",
                ])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->addPrefixes([
                    "en" => "",
                    "nl" => "/nl",
                ])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->setPrefixesByLocale([
                    "en" => "",
                    "nl" => "/nl",
                ])
            ;
        };
        ```', correct: false }
    help: |
      The `prefix()` method can accept an associative array where keys are locales and values are the corresponding prefixes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_51
  -
    question: 'What is the purpose of the `UrlMatcher` class in the Symfony Routing component?'
    answers:
      - { value: 'To generate URLs from route names and parameters.', correct: false }
      - { value: 'To match an incoming request path against the defined routes.', correct: true }
      - { value: 'To load route definitions from various configuration formats.', correct: false }
      - { value: 'To validate route parameters against their requirements.', correct: false }
    help: |
      `UrlMatcher` is responsible for taking a request path and finding the corresponding route.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_5
  -
    question: 'Which class represents a collection of `Route` objects in the Symfony Routing component?'
    answers:
      - { value: '`Symfony\\Component\\Routing\\RouteCollection`', correct: true }
      - { value: '`Symfony\\Component\\Routing\\RouteBag`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\RouteSet`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\RouteRegistry`', correct: false }
    help: |
      `RouteCollection` is the class that holds multiple `Route` objects.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'Which interface must a class implement to load routes in Symfony, typically for autoconfiguration?'
    answers:
      - { value: '`Symfony\\Bundle\\FrameworkBundle\\Routing\\RouteLoaderInterface`', correct: true }
      - { value: '`Symfony\\Component\\Config\\Loader\\LoaderInterface`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Loader\\LoaderInterface`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Loader\\RouteLoaderInterface`', correct: false }
    help: |
      `Symfony\\Bundle\\FrameworkBundle\\Routing\\RouteLoaderInterface` is the specific interface for route loaders in the FrameworkBundle.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'What is the purpose of the `UrlGenerator` class in the Symfony Routing component?'
    answers:
      - { value: 'To parse incoming URLs and extract route parameters.', correct: false }
      - { value: 'To create URLs based on a given route name and parameters.', correct: true }
      - { value: 'To validate the format of URLs before they are processed.', correct: false }
      - { value: 'To manage the caching of generated URLs.', correct: false }
    help: |
      `UrlGenerator` is used to generate URLs from route definitions.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_10
  -
    question: 'When defining a route in YAML, how can you specify that the controller is an invokable class (implements `__invoke()` method) instead of a specific method?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path: /blog
            controller: App\\Controller\\BlogController
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path: /blog
            controller: App\\Controller\\BlogController::__invoke
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path: /blog
            controller: App\\Controller\\BlogController::invoke
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_list:
            path: /blog
            controller: App\\Controller\\BlogController::class
        ```', correct: false }
    help: |
      If a controller implements `__invoke()`, you can omit the method name in the `controller` definition.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_2
  -
    question: 'How do you define a route named `blog_list` for the path `/blog` in a PHP configuration file (`config/routes.php`) where the controller is an invokable class?'
    answers:
      - { value: '```php
        // config/routes.php
        use App\\Controller\\BlogController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return function (RoutingConfigurator $routes): void {
            $routes->add("blog_list", "/blog")
                ->controller(BlogController::class)
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\BlogController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return function (RoutingConfigurator $routes): void {
            $routes->add("blog_list", "/blog")
                ->controller([BlogController::class, "__invoke"])
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\BlogController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return function (RoutingConfigurator $routes): void {
            $routes->add("blog_list", "/blog")
                ->controller("App\\Controller\\BlogController")
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes.php
        use App\\Controller\\BlogController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return function (RoutingConfigurator $routes): void {
            $routes->add("blog_list", "/blog")
                ->action(BlogController::class)
            ;
        };
        ```', correct: false }
    help: |
      For invokable controllers, you can pass the class name directly to the `controller()` method.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_3
  -
    question: 'What is the correct way to define an alias `product_details` for an existing route named `product_show` in YAML?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_details:
            alias: product_show
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_details:
            redirect: product_show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_details:
            link: product_show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        product_details:
            use_route: product_show
        ```', correct: false }
    help: |
      The `alias` option is used to create an alternate name for an existing route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_34
  -
    question: 'How do you define an alias `product_details` for an existing route named `product_show` using the PHP routing configurator?'
    answers:
      - { value: '```php
        // config/routes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
            $routes->alias("product_details", "product_show");
        };
        ```', correct: true }
      - { value: '```php
        // config/routes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
            $routes->addAlias("product_details", "product_show");
        };
        ```', correct: false }
      - { value: '```php
        // config/routes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
            $routes->link("product_details", "product_show");
        };
        ```', correct: false }
      - { value: '```php
        // config/routes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("product_show", "/product/{id}")
                    ->controller("App\\Controller\\ProductController::show");
            $routes->createAlias("product_details", "product_show");
        };
        ```', correct: false }
    help: |
      The `alias()` method on the `RoutingConfigurator` is used to define route aliases.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_34
  -
    question: 'What happens if a controller method requires an argument (e.g., `$slug`) but the defined route path does not provide a corresponding parameter?'
    answers:
      - { value: 'Symfony will automatically inject `null` into the argument.', correct: false }
      - { value: 'A `ControllerArgumentMissingException` will be thrown.', correct: false }
      - { value: 'A `RuntimeException` indicating that a value for the argument is missing will be thrown.', correct: true }
      - { value: 'The route will simply not match, and a 404 Not Found error will occur.', correct: false }
    help: |
      Symfony requires all controller arguments to be resolvable from route parameters or other sources. If a mandatory argument is missing, a runtime error occurs.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_72
  -
    question: 'When importing routes from a controller directory in YAML, how can you exclude specific files or subdirectories, for example, `Debug*Controller.php`?'
    answers:
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            exclude: \'../../src/Controller/{Debug*Controller.php}\'
        ```', correct: true }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            ignore: \'../../src/Controller/{Debug*Controller.php}\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            filter: \'!../../src/Controller/{Debug*Controller.php}\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            skip: \'../../src/Controller/{Debug*Controller.php}\'
        ```', correct: false }
    help: |
      The `exclude` option allows specifying glob patterns for files or directories to ignore during route import.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_38
  -
    question: 'Which of the following is a core class within the Symfony Routing component that represents a single route definition?'
    answers:
      - { value: '`Symfony\\Component\\Routing\\Route`', correct: true }
      - { value: '`Symfony\\Component\\Routing\\RouteDefinition`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Path`', correct: false }
      - { value: '`Symfony\\Component\\Routing\\Url`', correct: false }
    help: |
      The `Route` class encapsulates all information about a single route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'When defining a route in PHP, how do you add a requirement for the `page` parameter to be a digit (`\\d+`) using the `RoutingConfigurator`?'
    answers:
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->requirements(["page" => "\\d+"])
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page<\\d+>}")
            ->controller([BlogController::class, "list"])
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->setRequirement("page", "\\d+")
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->where("page", "\\d+")
        ;
        ```', correct: false }
    help: |
      Requirements can be set using the `requirements()` method or directly in the path.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_18
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_20
  -
    question: 'How do you configure a permanent redirect from `/legacy/doc` to an external URL `https://legacy.example.com/doc` using the PHP routing configurator?'
    answers:
      - { value: '```php
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("legacy_doc", "/legacy/doc")
                ->controller(RedirectController::class)
                ->defaults([
                    "path" => "https://legacy.example.com/doc",
                    "permanent" => true,
                ])
            ;
        };
        ```', correct: true }
      - { value: '```php
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("legacy_doc", "/legacy/doc")
                ->redirect("https://legacy.example.com/doc", permanent: true)
            ;
        };
        ```', correct: false }
      - { value: '```php
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("legacy_doc", "/legacy/doc")
                ->controller(RedirectController::class)
                ->path("https://legacy.example.com/doc")
                ->permanent(true)
            ;
        };
        ```', correct: false }
      - { value: '```php
        use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("legacy_doc", "/legacy/doc")
                ->toUrl("https://legacy.example.com/doc")
                ->status(301)
            ;
        };
        ```', correct: false }
    help: |
      The `RedirectController` can redirect to an absolute path or URL by setting the `path` default. `permanent` controls the HTTP status code.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_45
  -
    question: 'What is the default priority value for a Symfony route if not explicitly set?'
    answers:
      - { value: '0', correct: true }
      - { value: '1', correct: false }
      - { value: '100', correct: false }
      - { value: '`null`', correct: false }
    help: |
      The default priority for routes is 0. Routes with higher priority are matched first.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_23
  -
    question: 'Which of the following is NOT a valid special internal routing attribute in Symfony?'
    answers:
      - { value: '`_controller`', correct: false }
      - { value: '`_format`', correct: false }
      - { value: '`_fragment`', correct: false }
      - { value: '`_method`', correct: true }
    help: |
      `_method` is a requirement, not a special internal attribute that gets set on the request attributes like `_controller`, `_format`, or `_fragment`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'How would you configure a route in YAML to accept only `GET` and `HEAD` HTTP methods?'
    answers:
      - { value: '```yaml
        my_route:
            path: /my-path
            controller: App\\Controller\\MyController::index
            methods: [GET, HEAD]
        ```', correct: true }
      - { value: '```yaml
        my_route:
            path: /my-path
            controller: App\\Controller\\MyController::index
            method: GET|HEAD
        ```', correct: false }
      - { value: '```yaml
        my_route:
            path: /my-path
            controller: App\\Controller\\MyController::index
            http_methods: [GET, HEAD]
        ```', correct: false }
      - { value: '```yaml
        my_route:
            path: /my-path
            controller: App\\Controller\\MyController::index
            requirements:
                _method: GET|HEAD
        ```', correct: true }
    help: |
      HTTP method requirements can be set using the `methods` key or a `_method` requirement.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'What is the correct way to define a route in the PHP routing configurator that only responds to `PUT` and `DELETE` requests?'
    answers:
      - { value: '```php
        use App\\Controller\\ApiController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("api_resource", "/api/resource/{id}")
                ->controller([ApiController::class, "handleResource"])
                ->methods(["PUT", "DELETE"])
            ;
        };
        ```', correct: true }
      - { value: '```php
        use App\\Controller\\ApiController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("api_resource", "/api/resource/{id}")
                ->controller([ApiController::class, "handleResource"])
                ->setMethods(["PUT", "DELETE"])
            ;
        };
        ```', correct: false }
      - { value: '```php
        use App\\Controller\\ApiController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("api_resource", "/api/resource/{id}")
                ->controller([ApiController::class, "handleResource"])
                ->matchMethods(["PUT", "DELETE"])
            ;
        };
        ```', correct: false }
      - { value: '```php
        use App\\Controller\\ApiController;
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->add("api_resource", "/api/resource/{id}")
                ->controller([ApiController::class, "handleResource"])
                ->requirements(["_method" => "PUT|DELETE"])
            ;
        };
        ```', correct: true }
    help: |
      The `methods()` method or a `_method` requirement can be used to restrict allowed HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'What is the correct way to define a route in YAML that is only active in the `dev` environment?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        tools:
            path:       /tools
            controller: App\\Controller\\DefaultController::developerTools
            env:        dev
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        tools:
            path:       /tools
            controller: App\\Controller\\DefaultController::developerTools
            environment: dev
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        tools:
            path:       /tools
            controller: App\\Controller\\DefaultController::developerTools
            only_env:   dev
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        tools:
            path:       /tools
            controller: App\\Controller\\DefaultController::developerTools
            condition:  "kernel.environment == \'dev\'"
        ```', correct: false }
    help: |
      The `env` key in YAML route definitions restricts the route to a specific environment.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_6
  -
    question: 'When importing routes using YAML, how can you apply a URL prefix of `/blog` and a name prefix of `blog_` to all imported routes, and also define a global requirement that `_locale` must be `en|es|fr`?'
    answers:
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            prefix: \'/blog\'
            name_prefix: \'blog_\'
            requirements:
                _locale: \'en|es|fr\'
        ```', correct: true }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            options:
                prefix: \'/blog\'
                name_prefix: \'blog_\'
                requirements:
                    _locale: \'en|es|fr\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            defaults:
                _prefix: \'/blog\'
                _name_prefix: \'blog_\'
                _requirements:
                    _locale: \'en|es|fr\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            group:
                prefix: \'/blog\'
                name_prefix: \'blog_\'
                requirements:
                    _locale: \'en|es|fr\'
        ```', correct: false }
    help: |
      The `prefix`, `name_prefix`, and `requirements` options can be applied directly to the import definition in YAML.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_38
  -
    question: 'What is the purpose of the `RequestContext` class in Symfony''s Routing component?'
    answers:
      - { value: 'It holds fundamental information about the current request, such as the base URL, host, scheme, and HTTP method, used for route matching and URL generation.', correct: true }
      - { value: 'It stores user session data during the routing process.', correct: false }
      - { value: 'It manages the security context and user roles for route access control.', correct: false }
      - { value: 'It provides access to environment variables and application parameters within routing conditions.', correct: false }
    help: |
      `RequestContext` provides the necessary context for the `UrlMatcher` and `UrlGenerator` to function correctly.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_5
  -
    question: 'When is a `Symfony\\Component\\Routing\\Exception\\ResourceNotFoundException` typically thrown during the routing process in Symfony?'
    answers:
      - { value: 'When the requested URL does not match any defined route.', correct: true }
      - { value: 'When a controller method cannot be found for a matched route.', correct: false }
      - { value: 'When a route parameter fails to meet its requirements.', correct: false }
      - { value: 'When an internal server error occurs during route processing.', correct: false }
    help: |
      `ResourceNotFoundException` signifies that no route could be found for the given request.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_7
  -
    question: 'Which of the following is a valid way to define a route in PHP using the `Symfony\\Component\\Routing\\Route` class directly, without the `RoutingConfigurator`?'
    answers:
      - { value: '```php
        use Symfony\\Component\\Routing\\Route;
        $routes->add("hello", new Route("/hello/{name}", ["name" => "World"]));
        ```', correct: true }
      - { value: '```php
        use Symfony\\Component\\Routing\\Route;
        $routes->addRoute("hello", new Route("/hello/{name}", ["name" => "World"]));
        ```', correct: false }
      - { value: '```php
        use Symfony\\Component\\Routing\\Route;
        $routes->set("hello", new Route("/hello/{name}", ["name" => "World"]));
        ```', correct: false }
      - { value: '```php
        use Symfony\\Component\\Routing\\Route;
        $routes->define("hello", new Route("/hello/{name}", ["name" => "World"]));
        ```', correct: false }
    help: |
      Routes can be added to a `RouteCollection` directly using `add()`.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_4
  -
    question: 'What is the purpose of the `DelegatingLoader` in Symfony''s routing component?'
    answers:
      - { value: 'It is the main loader responsible for delegating route loading to specialized loaders based on resource type (e.g., YAML, attributes).', correct: true }
      - { value: 'It loads routes from a database and caches them.', correct: false }
      - { value: 'It handles the dynamic creation of routes at runtime.', correct: false }
      - { value: 'It is responsible for compiling routes into an optimized format.', correct: false }
    help: |
      The `DelegatingLoader` acts as a central point for loading routes from various sources.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'Which method of `Symfony\\Component\\Config\\Loader\\LoaderInterface` is used to check if the loader supports a given resource and type?'
    answers:
      - { value: '`supports(resource: string, type: string): bool`', correct: true }
      - { value: '`canLoad(resource: string, type: string): bool`', correct: false }
      - { value: '`isSupported(resource: string, type: string): bool`', correct: false }
      - { value: '`checkSupport(resource: string, type: string): bool`', correct: false }
    help: |
      The `supports()` method is part of the `LoaderInterface` to determine if a loader can handle a specific resource type.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'What is the purpose of the `_locale` special route parameter?'
    answers:
      - { value: 'It is used to set the locale on the current request.', correct: true }
      - { value: 'It defines the default language for the application.', correct: false }
      - { value: 'It is used for translating route names.', correct: false }
      - { value: 'It specifies the preferred language for generating URLs.', correct: false }
    help: |
      The `_locale` parameter directly influences the locale of the `Request` object.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which of the following is a valid way to define a route in XML with a requirement that the `page` parameter is a digit (`\\d+`)?'
    answers:
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list">
            <requirement key="page">\\d+</requirement>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page<\\d+>}" controller="App\\Controller\\BlogController::list"/>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list" requirements="page:\\d+"/>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list">
            <regex key="page">\\d+</regex>
        </route>
        ```', correct: false }
    help: |
      In XML, requirements are defined using a `<requirement>` tag with `key` and content.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_18
  -
    question: 'How do you configure a route in XML to allow the `token` parameter to contain slash characters (`/`)?'
    answers:
      - { value: '```xml
        <route id="share" path="/share/{token}" controller="App\\Controller\\DefaultController::share">
            <requirement key="token">.+</requirement>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="share" path="/share/{token}" controller="App\\Controller\\DefaultController::share" allow-slash="true"/>
        ```', correct: false }
      - { value: '```xml
        <route id="share" path="/share/{token<.+>}" controller="App\\Controller\\DefaultController::share"/>
        ```', correct: false }
      - { value: '```xml
        <route id="share" path="/share/{token}" controller="App\\Controller\\DefaultController::share">
            <option name="allow_slash" value="true"/>
        </route>
        ```', correct: false }
    help: |
      To allow slashes in a parameter, its requirement must be a regular expression that matches slashes, such as `.+`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_31
  -
    question: 'How do you set a default value for a route parameter `page` to `1` in XML?'
    answers:
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list">
            <default key="page">1</default>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list" default-page="1"/>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list">
            <option name="default_page" value="1"/>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_list" path="/blog/{page}" controller="App\\Controller\\BlogController::list" defaults="page:1"/>
        ```', correct: false }
    help: |
      In XML, default values are defined using `<default>` tags with a `key` attribute and content.
      https://symfony.com/doc/current/routing.html#setting-default-values
  -
    question: 'How do you configure a route in XML to match a dynamic subdomain, e.g., `{subdomain}.example.com`, with a default value for `subdomain` set to `m` and a requirement that `subdomain` can be `m` or `mobile`?'
    answers:
      - { value: '```xml
        <route id="mobile_homepage"
            path="/"
            host="{subdomain}.example.com"
            controller="App\\Controller\\MainController::mobileHomepage">
            <default key="subdomain">m</default>
            <requirement key="subdomain">m|mobile</requirement>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="mobile_homepage"
            path="/"
            host="{subdomain}.example.com"
            controller="App\\Controller\\MainController::mobileHomepage"
            defaults="subdomain:m"
            requirements="subdomain:m|mobile"/>
        ```', correct: false }
      - { value: '```xml
        <route id="mobile_homepage"
            path="/"
            domain="{subdomain}.example.com"
            controller="App\\Controller\\MainController::mobileHomepage">
            <default key="subdomain">m</default>
            <requirement key="subdomain">m|mobile</requirement>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="mobile_homepage"
            path="/"
            host="{subdomain}.example.com"
            controller="App\\Controller\\MainController::mobileHomepage">
            <option name="default_subdomain" value="m"/>
            <option name="subdomain_regex" value="m|mobile"/>
        </route>
        ```', correct: false }
    help: |
      Host-based routing with dynamic parameters in XML uses the `host` attribute along with `<default>` and `<requirement>` tags.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_47
  -
    question: 'How do you add a condition to a route in XML that checks if the HTTP method is `GET` or `HEAD` AND the `User-Agent` header matches `/firefox/i`?'
    answers:
      - { value: '```xml
        <route id="contact" path="/contact" controller="App\\Controller\\DefaultController::contact">
            <condition>context.getMethod() in [\'GET\', \'HEAD\'] and request.headers.get(\'User-Agent\') matches \'/firefox/i\'</condition>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="contact" path="/contact" controller="App\\Controller\\DefaultController::contact" condition="context.getMethod() in [\'GET\', \'HEAD\'] and request.headers.get(\'User-Agent\') matches \'/firefox/i\'"/>
        ```', correct: false }
      - { value: '```xml
        <route id="contact" path="/contact" controller="App\\Controller\\DefaultController::contact">
            <requirements>
                <method>GET|HEAD</method>
                <header key="User-Agent">/firefox/i</header>
            </requirements>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="contact" path="/contact" controller="App\\Controller\\DefaultController::contact">
            <expression>request.isMethod(\'GET\') or request.isMethod(\'HEAD\') and request.headers.get(\'User-Agent\') matches \'/firefox/i\'</expression>
        </route>
        ```', correct: false }
    help: |
      In XML, conditions are defined within a `<condition>` tag.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_7
  -
    question: 'How do you define localized paths for a single route named `about_us` in XML, with `/about-us` for English (`en`) and `/over-ons` for Dutch (`nl`)?'
    answers:
      - { value: '```xml
        <route id="about_us" controller="App\\Controller\\CompanyController::about">
            <path locale="en">/about-us</path>
            <path locale="nl">/over-ons</path>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="about_us" controller="App\\Controller\\CompanyController::about" path="/about-us">
            <localized-path locale="nl">/over-ons</localized-path>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="about_us" controller="App\\Controller\\CompanyController::about">
            <paths>
                <path locale="en">/about-us</path>
                <path locale="nl">/over-ons</path>
            </paths>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="about_us" controller="App\\Controller\\CompanyController::about" path-en="/about-us" path-nl="/over-ons"/>
        ```', correct: false }
    help: |
      Localized paths in XML are defined using multiple `<path>` tags with a `locale` attribute.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_50
  -
    question: 'Which of the following commands would you use to list all defined route aliases in a Symfony application?'
    answers:
      - { value: '`php bin/console debug:router --show-aliases`', correct: true }
      - { value: '`php bin/console debug:router --aliases`', correct: false }
      - { value: '`php bin/console router:aliases`', correct: false }
      - { value: '`php bin/console debug:router --list-aliases`', correct: false }
    help: |
      The `--show-aliases` option for `debug:router` displays route aliases.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_13
  -
    question: 'What is the recommended way to handle a situation where a route parameter is optional and should default to a specific value if not provided in the URL?'
    answers:
      - { value: 'Define a default value for the parameter in the route configuration.', correct: true }
      - { value: 'Make the parameter nullable in the controller method signature.', correct: false }
      - { value: 'Check for the parameter''s existence in the controller and assign a default value manually.', correct: false }
      - { value: 'Use a custom ParamConverter to provide the default value.', correct: false }
    help: |
      Symfony's routing system allows defining default values for parameters directly in the route configuration.
      https://symfony.com/doc/current/routing.html#setting-default-values
  -
    question: 'What is the purpose of the `UrlGeneratorInterface` in Symfony?'
    answers:
      - { value: 'It provides methods to generate URLs from route names and parameters.', correct: true }
      - { value: 'It is responsible for matching incoming requests to defined routes.', correct: false }
      - { value: 'It defines how routes are loaded from configuration files.', correct: false }
      - { value: 'It handles redirection logic within the application.', correct: false }
    help: |
      `UrlGeneratorInterface` is the contract for URL generation in Symfony.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_59
  -
    question: 'Which of the following is true about route aliases in Symfony?'
    answers:
      - { value: 'An alias creates a new route with a different name but the same path and controller as an existing route.', correct: false }
      - { value: 'An alias allows multiple names to point to the same route definition, useful for backward compatibility.', correct: true }
      - { value: 'Aliases are primarily used for internal routing and are not exposed publicly.', correct: false }
      - { value: 'Defining an alias automatically deprecates the original route name.', correct: false }
    help: |
      Route aliases provide an alternative name for an existing route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_34
  -
    question: 'What happens if two routes have the same path but different `host` requirements, and a request comes in that matches the path but only one of the hosts?'
    answers:
      - { value: 'The route with the matching host will be chosen.', correct: true }
      - { value: 'Symfony will throw an ambiguity error.', correct: false }
      - { value: 'The route defined first will be chosen.', correct: false }
      - { value: 'A 404 Not Found error will occur.', correct: false }
    help: |
      Host requirements are part of the matching process. If a host matches, that route is prioritized.
      https://symfony.com/doc/current/routing.html#host-requirements
  -
    question: 'You want to define a route in YAML that checks if a route parameter `id` is less than 1000. How would you do this?'
    answers:
      - { value: '```yaml
        post_show:
            path:       /posts/{id}
            controller: App\\Controller\\DefaultController::showPost
            condition:  "params[\'id\'] < 1000"
        ```', correct: true }
      - { value: '```yaml
        post_show:
            path:       /posts/{id}
            controller: App\\Controller\\DefaultController::showPost
            requirements:
                id: "<1000"
        ```', correct: false }
      - { value: '```yaml
        post_show:
            path:       /posts/{id}
            controller: App\\Controller\\DefaultController::showPost
            filter:     "id < 1000"
        ```', correct: false }
      - { value: '```yaml
        post_show:
            path:       /posts/{id}
            controller: App\\Controller\\DefaultController::showPost
            when:       "id < 1000"
        ```', correct: false }
    help: |
      The `condition` option allows using Expression Language, where `params` provides access to route parameters.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_7
  -
    question: 'What is the main role of `Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator`?'
    answers:
      - { value: 'It provides a fluent interface for defining routes in PHP configuration files.', correct: true }
      - { value: 'It is responsible for compiling and caching route definitions.', correct: false }
      - { value: 'It loads routes from annotations in controller classes.', correct: false }
      - { value: 'It generates URLs based on existing route definitions.', correct: false }
    help: |
      `RoutingConfigurator` simplifies route definition in PHP files.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_3
  -
    question: 'Which of the following is true about the order of route matching in Symfony?'
    answers:
      - { value: 'Routes are always matched in the order they are defined in the configuration files.', correct: false }
      - { value: 'Routes with more specific patterns are generally matched before more generic ones, unless `priority` is used.', correct: true }
      - { value: 'Routes are matched based on the alphabetical order of their names.', correct: false }
      - { value: 'Symfony uses a random order for route matching to ensure fairness.', correct: false }
    help: |
      Symfony's router tries to match the most specific route first. The `priority` option can override this default behavior.
      https://symfony.com/doc/current/routing.html#route-priority
  -
    question: 'How can you retrieve all available attributes (not just routing ones) from the `Request` object within a Symfony controller?'
    answers:
      - { value: '`$request->attributes->all();`', correct: true }
      - { value: '`$request->getAllAttributes();`', correct: false }
      - { value: '`$request->attributes->getAttributes();`', correct: false }
      - { value: '`$request->getAttributes();`', correct: false }
    help: |
      The `all()` method of the `ParameterBag` (which `attributes` is an instance of) returns all attributes as an associative array.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_42
  -
    question: 'What is the significance of the `type: attribute` option when importing routes in Symfony configuration?'
    answers:
      - { value: 'It specifies that routes should be loaded from XML files.', correct: false }
      - { value: 'It indicates that routes are defined using PHP attributes (annotations) within controller classes.', correct: true }
      - { value: 'It tells Symfony to automatically generate routes based on controller method names.', correct: false }
      - { value: 'It enables a special type of routing for API endpoints.', correct: false }
    help: |
      `type: attribute` (or `type: annotation` in older versions) is used to tell Symfony to look for routes defined via PHP attributes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_0
  -
    question: 'When configuring a redirect using `RedirectController`, what is the default HTTP status code for a temporary redirect if `permanent` is not set to `true` and `keepRequestMethod` is `false`?'
    answers:
      - { value: '302 Found', correct: true }
      - { value: '307 Temporary Redirect', correct: false }
      - { value: '301 Moved Permanently', correct: false }
      - { value: '303 See Other', correct: false }
    help: |
      By default, temporary redirects use the 302 status code.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'What is the main benefit of using a `RouteCollection` in the Symfony Routing component?'
    answers:
      - { value: 'It allows for efficient storage and retrieval of multiple route definitions.', correct: true }
      - { value: 'It automatically generates URLs for all contained routes.', correct: false }
      - { value: 'It provides a mechanism for route caching and optimization.', correct: false }
      - { value: 'It enables dynamic route creation at runtime.', correct: false }
    help: |
      `RouteCollection` is a fundamental class for organizing and managing routes.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_9
  -
    question: 'Which of the following is a valid method to define a route in PHP using the `RoutingConfigurator` that responds only to `GET` requests?'
    answers:
      - { value: '```php
        $routes->add("my_route", "/my-path")
            ->controller([MyController::class, "index"])
            ->methods(["GET"])
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("my_route", "/my-path")
            ->controller([MyController::class, "index"])
            ->get()
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("my_route", "/my-path")
            ->controller([MyController::class, "index"])
            ->requirements(["_method" => "GET"])
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("my_route", "/my-path")
            ->controller([MyController::class, "index"])
            ->allowMethods("GET")
        ;
        ```', correct: false }
    help: |
      The `methods()` method or a `_method` requirement can be used to restrict allowed HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'What is the purpose of the `load()` method in `Symfony\\Component\\Config\\Loader\\LoaderInterface`?'
    answers:
      - { value: 'It loads the routes from the given resource and returns a `RouteCollection`.', correct: true }
      - { value: 'It saves the current route configuration to a file.', correct: false }
      - { value: 'It validates the syntax of the route definitions.', correct: false }
      - { value: 'It compiles the routes for optimized performance.', correct: false }
    help: |
      The `load()` method is responsible for parsing a resource and returning a collection of routes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing/custom_route_loader.rst#_snippet_3
  -
    question: 'How can you apply an HTTPS scheme requirement to an entire group of imported routes using the PHP routing configurator?'
    answers:
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->schemes(["https"])
            ;
        };
        ```', correct: true }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->setSchemes("https")
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->forceHttps()
            ;
        };
        ```', correct: false }
      - { value: '```php
        // config/routes/attributes.php
        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;
        return static function (RoutingConfigurator $routes): void {
            $routes->import("../../src/Controller/", "attribute")
                ->requirements(["_scheme" => "https"])
            ;
        };
        ```', correct: false }
    help: |
      The `schemes()` method on an imported route collection applies scheme requirements to all imported routes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_68
  -
    question: 'What is the purpose of the `_controller` special route parameter?'
    answers:
      - { value: 'It specifies the fully qualified class name and method of the controller to execute.', correct: true }
      - { value: 'It defines the name of the service that acts as the controller.', correct: false }
      - { value: 'It is used for internal routing to a specific action within a controller.', correct: false }
      - { value: 'It determines the controller to be used for error pages.', correct: false }
    help: |
      The `_controller` parameter is fundamental for mapping a route to its executable code.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'When defining a route with a dynamic parameter like `{id}`, how does Symfony typically pass the value of this parameter to the controller method?'
    answers:
      - { value: 'As a named argument to the controller method, matching the parameter name.', correct: true }
      - { value: 'As an element in the `$_GET` superglobal array.', correct: false }
      - { value: 'As a property of the `Request` object.', correct: false }
      - { value: 'As the first argument to the controller method, regardless of name.', correct: false }
    help: |
      Symfony's routing system automatically injects route parameters as arguments to the controller method, matching by name.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_16
  -
    question: 'What is the primary reason for using `priority` on a route in Symfony?'
    answers:
      - { value: 'To ensure that a more specific route is matched before a more general (greedy) route that might otherwise capture the URL.', correct: true }
      - { value: 'To make the route load faster by giving it a higher processing order.', correct: false }
      - { value: 'To control the order in which routes are displayed by `debug:router`.', correct: false }
      - { value: 'To define the importance of the route for caching mechanisms.', correct: false }
    help: |
      Priority is crucial for resolving ambiguities when multiple routes could potentially match a given URL.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_23
  -
    question: 'You want to configure a route in YAML to redirect `/old-path` to `/new-path` permanently. Which of the following is the correct configuration?'
    answers:
      - { value: '```yaml
        old_path_redirect:
            path: /old-path
            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController
            defaults:
                path: /new-path
                permanent: true
        ```', correct: true }
      - { value: '```yaml
        old_path_redirect:
            path: /old-path
            redirect_to: /new-path
            status: 301
        ```', correct: false }
      - { value: '```yaml
        old_path_redirect:
            path: /old-path
            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController::url
            defaults:
                url: /new-path
                permanent: true
        ```', correct: false }
      - { value: '```yaml
        old_path_redirect:
            path: /old-path
            target: /new-path
            type: permanent
        ```', correct: false }
    help: |
      The `RedirectController` can redirect to an absolute path. `permanent: true` sets the 301 status code.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'What is the primary purpose of the `_format` special route parameter in Symfony routing?'
    answers:
      - { value: 'To define the expected file extension in the URL (e.g., `.html`, `.json`).', correct: true }
      - { value: 'To specify the data format for request bodies (e.g., `application/json`).', correct: false }
      - { value: 'To indicate the preferred output format for the response content.', correct: true }
      - { value: 'To control the rendering engine used for the view.', correct: false }
    help: |
      The `_format` parameter is used to determine the request format, which often corresponds to the file extension and influences the response `Content-Type`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which of the following is a valid way to define a route in XML that is only active in the `dev` environment?'
    answers:
      - { value: '```xml
        <route id="tools" path="/tools" controller="App\\Controller\\DefaultController::developerTools">
            <env>dev</env>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="tools" path="/tools" controller="App\\Controller\\DefaultController::developerTools" environment="dev"/>
        ```', correct: false }
      - { value: '```xml
        <route id="tools" path="/tools" controller="App\\Controller\\DefaultController::developerTools">
            <condition>kernel.environment == \'dev\'</condition>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="tools" path="/tools" controller="App\\Controller\\DefaultController::developerTools" only-env="dev"/>
        ```', correct: false }
    help: |
      In XML, the `<env>` tag specifies the environment for a route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_6
  -
    question: 'When importing routes from a controller directory in XML, how can you exclude specific files or subdirectories, for example, `Debug*Controller.php`?'
    answers:
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute" exclude="../../src/Controller/{Debug*Controller.php}"/>
        ```', correct: true }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute">
            <exclude pattern="../../src/Controller/{Debug*Controller.php}"/>
        </import>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute" ignore-files="../../src/Controller/{Debug*Controller.php}"/>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute">
            <filter type="exclude" value="../../src/Controller/{Debug*Controller.php}"/>
        </import>
        ```', correct: false }
    help: |
      The `exclude` attribute on the `<import>` tag allows specifying glob patterns for exclusion.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_39
  -
    question: 'What is the purpose of the `env()` function in Symfony''s Expression Language for routing conditions?'
    answers:
      - { value: 'It returns the value of an environment variable.', correct: true }
      - { value: 'It checks if the current environment matches a given value.', correct: false }
      - { value: 'It sets an environment variable for the current request.', correct: false }
      - { value: 'It retrieves a service based on its environment-specific alias.', correct: false }
    help: |
      The `env()` function provides access to environment variables.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'What is the primary benefit of defining a route as `stateless` in Symfony?'
    answers:
      - { value: 'It allows the route to be cached more aggressively by HTTP caches, as it guarantees no session-related side effects during matching.', correct: true }
      - { value: 'It prevents the route from being accessible to unauthenticated users.', correct: false }
      - { value: 'It ensures that the route does not rely on any external services.', correct: false }
      - { value: 'It makes the route immune to CSRF attacks.', correct: false }
    help: |
      Stateless routes are optimized for caching because they do not interact with the session.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_54
  -
    question: 'How do you define a route in XML that accepts only `POST` requests?'
    answers:
      - { value: '```xml
        <route id="submit_form" path="/submit" controller="App\\Controller\\FormController::submit">
            <method>POST</method>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="submit_form" path="/submit" controller="App\\Controller\\FormController::submit" methods="POST"/>
        ```', correct: false }
      - { value: '```xml
        <route id="submit_form" path="/submit" controller="App\\Controller\\FormController::submit">
            <requirements>
                <method>POST</method>
            </requirements>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="submit_form" path="/submit" controller="App\\Controller\\FormController::submit" http-method="POST"/>
        ```', correct: false }
    help: |
      HTTP method requirements can be set using a `<method>` tag or a `_method` requirement.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'Which of the following is the correct way to define a route with a dynamic slug parameter (`{slug}`) in YAML?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        blog_show:
            path:       /blog/{slug}
            controller: App\\Controller\\BlogController::show
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        blog_show:
            url:        /blog/{slug}
            action: App\\Controller\\BlogController::show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_show:
            route:      /blog/{slug}
            handler: App\\Controller\\BlogController::show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        blog_show:
            path:       /blog/:slug
            controller: App\\Controller\\BlogController::show
        ```', correct: false }
    help: |
      Dynamic parameters are enclosed in curly braces `{}` in the `path`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_16
  -
    question: 'What is the purpose of the `UrlMatcher` class in Symfony''s Routing component?'
    answers:
      - { value: 'It takes an incoming request path and attempts to find a matching route definition.', correct: true }
      - { value: 'It generates URLs based on route names and parameters.', correct: false }
      - { value: 'It validates the syntax of route definitions.', correct: false }
      - { value: 'It caches the results of route matching for performance.', correct: false }
    help: |
      The `UrlMatcher` is the core component for matching requests to routes.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_5
  -
    question: 'How do you define a route in PHP attributes with a default value for the `page` parameter set to `1`?'
    answers:
      - { value: '```php
        #[Route("/articles/{page}", defaults: ["page" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/articles/{page}", default: 1)]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/articles/{page?}", defaults: ["page" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/articles/{page}", options: ["default_value" => 1])]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `defaults` option is used to set default values for route parameters.
      https://symfony.com/doc/current/routing.html#setting-default-values
  -
    question: 'When is it appropriate to use the `stateless: true` option on a Symfony route?'
    answers:
      - { value: 'When the route should not interact with the user''s session, typically for API endpoints or highly cacheable content.', correct: true }
      - { value: 'When the route should only be accessible to unauthenticated users.', correct: false }
      - { value: 'When the route needs to bypass all security checks.', correct: false }
      - { value: 'When the route is intended for internal use only and not exposed to the public.', correct: false }
    help: |
      `stateless` routes are ideal for scenarios where session management is not required, allowing for better caching.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_54
  -
    question: 'Which of the following describes the `_fragment` special route parameter?'
    answers:
      - { value: 'It is an optional part of a URL that starts with a `#` character and is used to identify a portion of a document.', correct: true }
      - { value: 'It is a mandatory parameter that specifies a section of the application to load.', correct: false }
      - { value: 'It is used to define a sub-route within a larger route.', correct: false }
      - { value: 'It refers to a JavaScript fragment that should be executed on page load.', correct: false }
    help: |
      The `_fragment` parameter corresponds to the URL fragment identifier.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'What is the purpose of the `namePrefix` option when importing routes in the PHP routing configurator?'
    answers:
      - { value: 'It adds a prefix to the URL path of all imported routes.', correct: false }
      - { value: 'It adds a prefix to the names of all imported routes.', correct: true }
      - { value: 'It defines a namespace for the controllers of imported routes.', correct: false }
      - { value: 'It specifies a common name for the group of imported routes.', correct: false }
    help: |
      `namePrefix()` is used to add a common prefix to the names of all routes within an imported collection.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_40
  -
    question: 'How can you apply a URL prefix of `/blog` and a name prefix of `blog_` to all imported routes in XML configuration, while also defining a global requirement that `_locale` must be `en|es|fr`?'
    answers:
      - { value: '```xml
        <import resource="../../src/Controller/"
            type="attribute"
            prefix="/blog"
            name-prefix="blog_">
            <requirement key="_locale">en|es|fr</requirement>
        </import>
        ```', correct: true }
      - { value: '```xml
        <import resource="../../src/Controller/"
            type="attribute"
            url-prefix="/blog"
            route-name-prefix="blog_">
            <requirement key="_locale">en|es|fr</requirement>
        </import>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/"
            type="attribute">
            <options prefix="/blog" name-prefix="blog_"/>
            <requirements>
                <requirement key="_locale">en|es|fr</requirement>
            </requirements>
        </import>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/"
            type="attribute"
            group-prefix="/blog"
            group-name-prefix="blog_">
            <requirement key="_locale">en|es|fr</requirement>
        </import>
        ```', correct: false }
    help: |
      The `prefix` and `name-prefix` attributes, along with nested `<requirement>` tags, are used for grouping imported routes in XML.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_39
  -
    question: 'What is the purpose of the `context` variable available in Symfony''s Expression Language for routing conditions?'
    answers:
      - { value: 'It is an instance of `Symfony\\Component\\Routing\\RequestContext`, providing information about the route being matched.', correct: true }
      - { value: 'It represents the current application environment (e.g., `dev`, `prod`).', correct: false }
      - { value: 'It provides access to the current user''s security context.', correct: false }
      - { value: 'It contains all global parameters defined in `services.yaml`.', correct: false }
    help: |
      The `context` variable provides access to the `RequestContext` object, which holds essential routing information.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'When is a `Symfony\\Component\\Routing\\Exception\\RouteNotFoundException` thrown?'
    answers:
      - { value: 'When attempting to generate a URL for a route name that does not exist.', correct: true }
      - { value: 'When the router cannot match an incoming URL to any defined route.', correct: false }
      - { value: 'When a route''s controller cannot be found or is not callable.', correct: false }
      - { value: 'When a route''s requirements are not met by the incoming request.', correct: false }
    help: |
      `RouteNotFoundException` specifically indicates that a route with the given name could not be found for URL generation.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_63
  -
    question: 'How can you configure a route in XML to redirect from `/doc` to an internal route named `doc_page` permanently, preserving query parameters and the HTTP method?'
    answers:
      - { value: '```xml
        <route id="doc_shortcut" path="/doc" controller="Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController">
            <default key="route">doc_page</default>
            <default key="permanent">true</default>
            <default key="keepQueryParams">true</default>
            <default key="keepRequestMethod">true</default>
        </route>
        ```', correct: true }
      - { value: '```xml
        <route id="doc_shortcut" path="/doc" controller="Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController"
            redirect-to="doc_page" permanent="true" keep-query-params="true" keep-request-method="true"/>
        ```', correct: false }
      - { value: '```xml
        <route id="doc_shortcut" path="/doc" controller="Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController">
            <defaults route="doc_page" permanent="true" keepQueryParams="true" keepRequestMethod="true"/>
        </route>
        ```', correct: false }
      - { value: '```xml
        <route id="doc_shortcut" path="/doc" controller="Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController">
            <options route="doc_page" permanent="true" keepQueryParams="true" keepRequestMethod="true"/>
        </route>
        ```', correct: false }
    help: |
      The `RedirectController` uses `default` tags for configuration, including `route`, `permanent`, `keepQueryParams`, and `keepRequestMethod`.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_44
  -
    question: 'What is the purpose of the `params` variable in Symfony''s Expression Language for routing conditions?'
    answers:
      - { value: 'It is an array containing all matched route parameters for the current route.', correct: true }
      - { value: 'It provides access to the query parameters of the current request.', correct: false }
      - { value: 'It contains all parameters defined in `services.yaml`.', correct: false }
      - { value: 'It is used to pass additional parameters to the controller method.', correct: false }
    help: |
      The `params` variable allows you to access the values of route parameters within your conditions.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'Which of the following is the correct way to define a route in PHP attributes that accepts only `GET` and `HEAD` HTTP methods?'
    answers:
      - { value: '```php
        #[Route("/contact", name: "contact", methods: ["GET", "HEAD"])]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/contact", name: "contact", method: "GET|HEAD")]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/contact", name: "contact", httpMethods: ["GET", "HEAD"])]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/contact", name: "contact", requirements: ["_method" => "GET|HEAD"])]
        public function contact(): Response
        {
            // ...
        }
        ```', correct: true }
    help: |
      The `methods` option or a `_method` requirement can be used to restrict allowed HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements
  -
    question: 'What is the primary purpose of the `_locale` special route parameter?'
    answers:
      - { value: 'It is used to set the locale on the `Request` object, influencing translation and localization.', correct: true }
      - { value: 'It defines the default language for the application if no other locale is specified.', correct: false }
      - { value: 'It is used to translate route names into different languages.', correct: false }
      - { value: 'It specifies the preferred language for generating URLs.', correct: false }
    help: |
      The `_locale` parameter is directly tied to the localization features of Symfony.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which of the following is true about the `stateless` option on a Symfony route?'
    answers:
      - { value: 'It prevents the route from accessing or creating a session during the request lifecycle.', correct: true }
      - { value: 'It makes the route accessible without authentication.', correct: false }
      - { value: 'It forces the route to always return a JSON response.', correct: false }
      - { value: 'It marks the route as deprecated and suggests an alternative.', correct: false }
    help: |
      A stateless route ensures no session is started or used, which is beneficial for performance and caching.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_54
  -
    question: 'When defining a route with a dynamic parameter like `{page}`, how can you specify a regular expression requirement for this parameter directly in the path using PHP attributes?'
    answers:
      - { value: '```php
        #[Route("/blog/{page<\\\\d+>}", name: "blog_list")]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/blog/{page: \\\\d+}", name: "blog_list")]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{page(regex=\'\\\\d+\')}", name: "blog_list")]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/blog/{page, \\\\d+}", name: "blog_list")]
        public function list(int $page): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      Regular expression requirements can be embedded directly into the route path using the `<REGEX>` syntax.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_20
  -
    question: 'What is the purpose of the `UrlGenerator` class in the Symfony Routing component?'
    answers:
      - { value: 'It is used to generate URLs from route names and parameters, based on the defined `RouteCollection`.', correct: true }
      - { value: 'It matches incoming URLs to their corresponding routes.', correct: false }
      - { value: 'It loads route definitions from various sources.', correct: false }
      - { value: 'It provides debugging information for routing issues.', correct: false }
    help: |
      `UrlGenerator` is the component responsible for constructing URLs.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/routing.rst#_snippet_10
  -
    question: 'Which of the following describes the `_format` special route parameter?'
    answers:
      - { value: 'The matched value is used to set the "request format" of the `Request` object, influencing the `Content-Type` of the response.', correct: true }
      - { value: 'It specifies the format of the incoming request body (e.g., JSON, XML).', correct: false }
      - { value: 'It defines the default output format for all responses from the application.', correct: false }
      - { value: 'It is used to determine the template engine to render the view.', correct: false }
    help: |
      The `_format` parameter is crucial for content negotiation and setting the response type.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'How can you define a route in PHP attributes that allows the `token` parameter to contain slash characters (`/`)?'
    answers:
      - { value: '```php
        #[Route("/share/{token}", name: "share", requirements: ["token" => ".+"])]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/share/{token<.+>}", name: "share")]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/share/{token}", name: "share", allow_slashes: true)]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/share/{token}", name: "share", options: ["slash_tolerant" => true])]
        public function share($token): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      A permissive regex like `.+` is used to allow slashes in route parameters.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_31
  -
    question: 'Which of the following is the correct way to define a route with a dynamic slug parameter (`{slug}`) in XML?'
    answers:
      - { value: '```xml
        <route id="blog_show" path="/blog/{slug}" controller="App\\Controller\\BlogController::show"/>
        ```', correct: true }
      - { value: '```xml
        <route id="blog_show" url="/blog/{slug}" action="App\\Controller\\BlogController::show"/>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_show" path="/blog/:slug" controller="App\\Controller\\BlogController::show"/>
        ```', correct: false }
      - { value: '```xml
        <route id="blog_show" route-path="/blog/{slug}" controller="App\\Controller\\BlogController::show"/>
        ```', correct: false }
    help: |
      Dynamic parameters are enclosed in curly braces `{}` in the `path` attribute.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_16
  -
    question: 'What is the purpose of the `_controller` special route parameter?'
    answers:
      - { value: 'It specifies the controller and method that will handle the request for the matched route.', correct: true }
      - { value: 'It defines the name of the service that provides the routing logic.', correct: false }
      - { value: 'It is used to pass additional arguments to the controller.', correct: false }
      - { value: 'It determines the security role required to access the route.', correct: false }
    help: |
      The `_controller` parameter is crucial for Symfony to know which code to execute for a given route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'How can you apply locale-specific URL prefixes to imported routes using YAML configuration, for example, no prefix for `en` and `/nl` for `nl`?'
    answers:
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            prefix:
                en: \'\'
                nl: \'/nl\'
        ```', correct: true }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            locale_prefix:
                en: \'\'
                nl: \'/nl\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            prefixes_by_locale:
                en: \'\'
                nl: \'/nl\'
        ```', correct: false }
      - { value: '```yaml
        # config/routes/attributes.yaml
        controllers:
            resource: \'../../src/Controller/\'
            type: attribute
            options:
                locale_prefixes:
                    en: \'\'
                    nl: \'/nl\'
        ```', correct: false }
    help: |
      The `prefix` option in YAML can accept a map of locales to their respective prefixes.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_51
  -
    question: 'What is the purpose of the `request` variable available in Symfony''s Expression Language for routing conditions?'
    answers:
      - { value: 'It is the Symfony `Request` object representing the current HTTP request.', correct: true }
      - { value: 'It contains the request parameters from the URL query string.', correct: false }
      - { value: 'It provides access to the request headers only.', correct: false }
      - { value: 'It is used to modify the incoming request before routing.', correct: false }
    help: |
      The `request` variable allows access to the full `Request` object for detailed conditional logic.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_9
  -
    question: 'How do you define a basic route named `product_show` for the path `/product/{id}` in a Symfony YAML configuration file?'
    answers:
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            controller: App\\Controller\\ProductController::show
        ```', correct: true }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            url: /product/{id}
            action: App\\Controller\\ProductController::show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            route: /product/{id}
            handler: App\\Controller\\ProductController::show
        ```', correct: false }
      - { value: '```yaml
        # config/routes.yaml
        product_show:
            path: /product/{id}
            defaults:
                _controller: App\\Controller\\ProductController::show
        ```', correct: false }
    help: |
      The `path` and `controller` keys are used to define a route in YAML.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_33
  -
    question: 'How do you define a route in PHP attributes that explicitly sets the default format to `json`?'
    answers:
      - { value: '```php
        #[Route("/api/data", name: "api_data", format: "json")]
        public function apiData(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/api/data", name: "api_data", defaults: ["_format" => "json"])]
        public function apiData(): Response
        {
            // ...
        }
        ```', correct: true }
      - { value: '```php
        #[Route("/api/data", name: "api_data", response_format: "json")]
        public function apiData(): Response
        {
            // ...
        }
        ```', correct: false }
      - { value: '```php
        #[Route("/api/data", name: "api_data", options: ["format" => "json"])]
        public function apiData(): Response
        {
            // ...
        }
        ```', correct: false }
    help: |
      The `format` option or a `_format` default can be used to set the default format for a route.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_28
  -
    question: 'What is the purpose of the `_fragment` special route parameter?'
    answers:
      - { value: 'It is used to set the fragment identifier (the part of a URL after `#`) when generating a URL.', correct: true }
      - { value: 'It defines a small, reusable part of a route definition.', correct: false }
      - { value: 'It specifies a section of a web page to be loaded asynchronously.', correct: false }
      - { value: 'It is used for internal navigation within a single-page application.', correct: false }
    help: |
      The `_fragment` parameter corresponds to the URL fragment.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'How can you apply an HTTPS scheme requirement to an entire group of imported routes using XML configuration?'
    answers:
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute" schemes="https"/>
        ```', correct: true }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute">
            <scheme>https</scheme>
        </import>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute" force-https="true"/>
        ```', correct: false }
      - { value: '```xml
        <import resource="../../src/Controller/" type="attribute">
            <requirements>
                <requirement key="_scheme">https</requirement>
            </requirements>
        </import>
        ```', correct: false }
    help: |
      The `schemes` attribute on the `<import>` tag applies scheme requirements.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_68
  -
    question: 'What is the purpose of the `_controller` special route parameter?'
    answers:
      - { value: 'It defines the controller and action that Symfony should execute when the route is matched.', correct: true }
      - { value: 'It is used to pass data from the router to the controller.', correct: false }
      - { value: 'It specifies the name of the route for URL generation.', correct: false }
      - { value: 'It determines the HTTP method allowed for the route.', correct: false }
    help: |
      The `_controller` parameter is essential for linking a URL to its corresponding PHP code.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'Which of the following is true about the `_locale` special route parameter?'
    answers:
      - { value: 'It is automatically set on the `Request` object and can be used for internationalization.', correct: true }
      - { value: 'It is a mandatory parameter for all routes in a multilingual application.', correct: false }
      - { value: 'It defines the default timezone for the application.', correct: false }
      - { value: 'It is only used when generating URLs, not for matching incoming requests.', correct: false }
    help: |
      The `_locale` parameter is fundamental for Symfony's localization features.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'What is the purpose of the `_format` special route parameter?'
    answers:
      - { value: 'It is used to set the "request format" of the `Request` object, which influences the `Content-Type` of the response (e.g., `application/json` for `json` format).', correct: true }
      - { value: 'It defines the expected file extension for the URL.', correct: false }
      - { value: 'It specifies the data format for parameters passed in the URL.', correct: false }
      - { value: 'It controls the rendering format of Twig templates.', correct: false }
    help: |
      The `_format` parameter helps Symfony determine how to handle the response based on the requested format.
      https://github.com/symfony/symfony-docs/blob/7.3/routing.rst#_snippet_27
  -
    question: 'When defining a route in PHP using the `RoutingConfigurator`, how do you set a default value for the `page` parameter to `1`?'
    answers:
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->defaults(["page" => 1])
        ;
        ```', correct: true }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->setDefault("page", 1)
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->options(["default_page" => 1])
        ;
        ```', correct: false }
      - { value: '```php
        $routes->add("blog_list", "/blog/{page}")
            ->controller([BlogController::class, "list"])
            ->withDefault("page", 1)
        ;
        ```', correct: false }
    help: |
      The `defaults()` method is used to set default values for route parameters.
      https://symfony.com/doc/current/routing.html#setting-default-values